rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    function isSignedIn() {
      return request.auth != null;
    }

    function isParticipant(conversationId) {
      return isSignedIn() && 
        request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }

    // --- Users ---
    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if request.auth.uid == userId;

      // Digital Passport Verifications
      match /verifications/{provider} {
        allow read: if true; // Publicly verifiable claims
        allow write: if isSignedIn() && request.auth.uid == userId;
      }
      
      // Sovereign Vault (Encrypted Backups)
      match /vault/{vaultId} {
        allow read, write: if isSignedIn() && request.auth.uid == userId;
      }
    }

    // --- Nicknames (Availability & Mapping) ---
    match /nicknames/{nickname} {
      allow read: if true; // Public check for availability
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.uid == request.auth.uid;
    }

    // --- Public Profiles ---
    match /profiles/{nickname} {
      allow read: if true; // Public link-in-bio
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.uid == request.auth.uid;
    }

    // --- Link Blocks (Bento Grid) ---
    match /link_blocks/{blockId} {
      allow read: if true; // Visibility filtering handled by client or refined here
      allow create: if isSignedIn() && request.resource.data.user_id == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.user_id == request.auth.uid;
    }

    // --- Access Requests & Grants (P2P Handshake) ---
    match /access_requests/{requestId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.requester_id || request.auth.uid == resource.data.owner_id);
      allow create: if isSignedIn() && request.resource.data.requester_id == request.auth.uid;
      allow update, delete: if isSignedIn() && (request.auth.uid == resource.data.requester_id || request.auth.uid == resource.data.owner_id);
    }

    // --- Connections (Friends) ---
    match /connections/{connectionId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.requester_id || request.auth.uid == resource.data.receiver_id);
      allow create: if isSignedIn() && request.resource.data.requester_id == request.auth.uid;
      allow update, delete: if isSignedIn() && (request.auth.uid == resource.data.requester_id || request.auth.uid == resource.data.receiver_id);
    }

    // --- Conversations ---
    match /conversations/{conversationId} {
      // Participant check for reading metadata
      allow read: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      
      // Strict creation: must be a participant, must provide encrypted keys
      allow create: if isSignedIn() 
        && request.auth.uid in request.resource.data.participantIds
        && request.resource.data.keys.keys().hasAll(request.resource.data.participantIds);
      
      // Allow metadata updates (lastMessage, updatedAt) only for participants
      allow update: if isParticipant(conversationId);

      // --- Messages Sub-collection ---
      match /messages/{messageId} {
        // No cross-conversation access: enforced by path nesting and isParticipant
        allow read: if isParticipant(conversationId);
        
        // Write-once policy: No updates, no deletes (except by TTL service or sender for soft-delete cleanup)
        allow create: if isParticipant(conversationId)
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.createdAt == request.time
          && request.resource.data.keys().hasAll(['content', 'iv', 'senderId', 'createdAt']);
        
        allow update: if false;
        allow delete: if isParticipant(conversationId) && (resource.data.senderId == request.auth.uid);
      }

      // --- Presence Sub-collection ---
      match /presence/{userId} {
        allow read: if isParticipant(conversationId);
        // Users can only update their own presence
        allow write: if isParticipant(conversationId) && request.auth.uid == userId;
      }
    }
    
    // --- Global Collection Group for TTL ---
    match /{path=**}/messages/{messageId} {
      allow read: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/$(path)).data.participantIds;
    }
  }
}
